// {{APP_NAME}} â€” Corral Auth Setup (PostgreSQL)
// Works with: Railway, Fly.io, Supabase, Neon, Render, any Postgres host
// Set DATABASE_URL in your .env:
//   Railway:  postgresql://postgres:xxx@xxx.railway.app:5432/railway
//   Fly.io:   postgresql://postgres:xxx@xxx.flycast:5432/app
//   Supabase: postgresql://postgres:xxx@xxx.supabase.co:5432/postgres
//   Neon:     postgresql://xxx@xxx.neon.tech/neondb?sslmode=require
//   Local:    postgresql://localhost:5432/myapp

import { betterAuth } from "better-auth";
import { admin } from "better-auth/plugins";
import pg from "pg";

const pool = new pg.Pool({
  connectionString: process.env.DATABASE_URL,
  // Neon/Supabase/Railway all need SSL in production
  ssl: process.env.DATABASE_URL?.includes("localhost") ? false : { rejectUnauthorized: false },
  max: 10,
});

// Auto-bootstrap tables on first connection
async function bootstrapDatabase(pool: pg.Pool) {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS "user" (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT NOT NULL UNIQUE,
        "emailVerified" BOOLEAN NOT NULL DEFAULT false,
        image TEXT,
        plan TEXT NOT NULL DEFAULT 'free',
        "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        role TEXT DEFAULT 'user',
        banned BOOLEAN DEFAULT false,
        "banReason" TEXT,
        "banExpires" TIMESTAMPTZ
      );
      CREATE TABLE IF NOT EXISTS "session" (
        id TEXT PRIMARY KEY,
        "userId" TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
        token TEXT NOT NULL UNIQUE,
        "expiresAt" TIMESTAMPTZ NOT NULL,
        "ipAddress" TEXT,
        "userAgent" TEXT,
        "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW()
      );
      CREATE TABLE IF NOT EXISTS "account" (
        id TEXT PRIMARY KEY,
        "userId" TEXT NOT NULL REFERENCES "user"(id) ON DELETE CASCADE,
        "accountId" TEXT NOT NULL,
        "providerId" TEXT NOT NULL,
        "accessToken" TEXT,
        "refreshToken" TEXT,
        "accessTokenExpiresAt" TIMESTAMPTZ,
        "refreshTokenExpiresAt" TIMESTAMPTZ,
        scope TEXT,
        password TEXT,
        "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW()
      );
      CREATE TABLE IF NOT EXISTS "verification" (
        id TEXT PRIMARY KEY,
        identifier TEXT NOT NULL,
        value TEXT NOT NULL,
        "expiresAt" TIMESTAMPTZ NOT NULL,
        "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW()
      );
      CREATE TABLE IF NOT EXISTS "subscription" (
        id TEXT PRIMARY KEY,
        plan TEXT NOT NULL DEFAULT 'free',
        "referenceId" TEXT NOT NULL,
        "stripeCustomerId" TEXT,
        "stripeSubscriptionId" TEXT,
        status TEXT,
        "periodStart" TIMESTAMPTZ,
        "periodEnd" TIMESTAMPTZ,
        "cancelAtPeriodEnd" BOOLEAN DEFAULT false,
        seats INTEGER DEFAULT 1
      );
      CREATE INDEX IF NOT EXISTS idx_session_token ON "session"(token);
      CREATE INDEX IF NOT EXISTS idx_session_userId ON "session"("userId");
      CREATE INDEX IF NOT EXISTS idx_account_userId ON "account"("userId");
      CREATE INDEX IF NOT EXISTS idx_user_email ON "user"(email);
    `);
    console.log("ðŸ“¦ Database tables ready");
  } finally {
    client.release();
  }
}

// Bootstrap on import (runs once at startup)
bootstrapDatabase(pool).catch(err => {
  console.error("Failed to bootstrap database:", err.message);
  // Don't crash â€” tables may already exist
});

// â”€â”€â”€ Auto-seed admin user on first run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Set SEED_ADMIN_EMAIL + SEED_ADMIN_PASSWORD in .env to auto-create admin.
async function seedAdminIfNeeded() {
  let adminEmail = process.env.SEED_ADMIN_EMAIL || process.env.ADMIN_EMAIL || "";
  let adminPassword = process.env.SEED_ADMIN_PASSWORD || process.env.ADMIN_PASSWORD || "";
  let adminName = "Admin";
  let adminPlan = "{{DEFAULT_PAID_PLAN}}" || "free";

  // Read from corral.yaml if env vars not set
  const fs = await import("fs");
  const pathMod = await import("path");
  for (const p of ["corral.yaml", "../corral.yaml", "../frontend/corral.yaml"]) {
    const resolved = pathMod.resolve(process.cwd(), p);
    if (fs.existsSync(resolved)) {
      const content = fs.readFileSync(resolved, "utf-8");
      const em = content.match(/seed:\s*\n\s+admin:\s*\n[\s\S]*?email:\s*(\S+)/);
      const pm = content.match(/seed:\s*\n\s+admin:\s*\n[\s\S]*?password:\s*(\S+)/);
      const nm = content.match(/seed:\s*\n\s+admin:\s*\n[\s\S]*?name:\s*(.+)/);
      if (em && !adminEmail) adminEmail = em[1];
      if (pm && !adminPassword) adminPassword = pm[1];
      if (nm) adminName = nm[1].trim();
      break;
    }
  }

  if (!adminEmail || !adminPassword) return;

  const client = await pool.connect();
  try {
    const existing = await client.query(`SELECT id FROM "user" WHERE role = 'admin' LIMIT 1`);
    if (existing.rows.length > 0) return;

    const bcrypt = await import("bcryptjs").catch(() => null);
    const { createHash } = await import("crypto");
    const hashedPw = bcrypt
      ? await bcrypt.default.hash(adminPassword, 12)
      : createHash("sha256").update(adminPassword).digest("hex");

    const id = Math.random().toString(36).slice(2) + Date.now().toString(36);
    const accountId = Math.random().toString(36).slice(2);
    const now = new Date();

    await client.query(
      `INSERT INTO "user" (id, name, email, "emailVerified", plan, role, "createdAt", "updatedAt")
       VALUES ($1, $2, $3, true, $4, 'admin', $5, $5)`,
      [id, adminName, adminEmail, adminPlan, now]
    );
    await client.query(
      `INSERT INTO "account" (id, "userId", "accountId", "providerId", password, "createdAt", "updatedAt")
       VALUES ($1, $2, $3, 'credential', $4, $5, $5)`,
      [accountId, id, accountId, hashedPw, now]
    );
    console.log(`ðŸ¤  Corral: Seeded admin user â†’ ${adminEmail} (role=admin)`);
  } catch (e: any) {
    console.warn(`ðŸ¤  Corral: Could not seed admin: ${e.message}`);
  } finally {
    client.release();
  }
}

// Auto-detect frontend port for CORS
const frontendPort = process.env.FRONTEND_PORT || process.env.CLIENT_PORT || "3000";
const frontendOrigin = process.env.CORS_ORIGIN || `http://localhost:${frontendPort}`;

export const auth = betterAuth({
  // Better Auth auto-detects pg.Pool via "connect" in pool
  database: pool,
  baseURL: process.env.BETTER_AUTH_URL || "http://localhost:{{PORT}}",
  basePath: "/api/auth",
  secret: process.env.BETTER_AUTH_SECRET,
  emailAndPassword: { enabled: true },
  plugins: [admin()],
  session: { expiresIn: 60 * 60 * 24 * 30 },
  user: {
    additionalFields: {
      plan: {
        type: "string" as const,
        defaultValue: "free",
      },
    },
  },
  trustedOrigins: [
    frontendOrigin,
    frontendOrigin.replace("localhost", "127.0.0.1"),
    process.env.APP_URL,
    ...(process.env.TRUSTED_ORIGINS || "").split(",").map(o => o.trim()).filter(Boolean),
  ].filter(Boolean) as string[],
});

// Run seed after auth is configured (non-blocking)
seedAdminIfNeeded().catch(() => {});

export type Session = typeof auth.$Infer.Session;
