// {{APP_NAME}} â€” Corral Admin + Profile + Billing API (generated by Corral)
//
// Mounts all admin, profile, and billing routes onto your Express app.
//
// Usage in your server file:
//
//   import express from "express";
//   import { mountCorralRoutes } from "./corral-admin-api.js";
//
//   const app = express();
//
//   // âš ï¸  IMPORTANT: Call mountCorralRoutes BEFORE app.use(express.json())
//   //    The Stripe webhook needs the raw request body.
//   mountCorralRoutes(app);
//
//   app.use(express.json());
//   // ... rest of your app
//
// Routes registered:
//   GET    /api/admin/users
//   PUT    /api/admin/users/:id/plan
//   PUT    /api/admin/users/:id/role
//   GET    /api/admin/plans
//   POST   /api/admin/plans
//   PUT    /api/profile/name
//   PUT    /api/profile/password
//   DELETE /api/profile/delete
//   POST   /api/billing/checkout
//   POST   /api/billing/webhook
//
// Template vars substituted at generation time:
//   PAID_PLAN         = "{{PAID_PLAN}}"
//   STRIPE_PRICE_FIELD = "stripe_price_id"
//   TRIAL_DAYS        = {{TRIAL_DAYS}}
//   SUCCESS_URL       = "{{SUCCESS_URL}}"
//   CANCEL_URL        = "{{CANCEL_URL}}"

import express from "express";
import { createRequire } from "module";
import { readFileSync, existsSync } from "fs";
import { resolve, join } from "path";
import { auth } from "./corral.js";
import Database from "better-sqlite3";

// â”€â”€â”€ DB helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Open a short-lived connection to corral.db.
 * Always call db.close() when done to avoid WAL file accumulation.
 */
function getDb(): Database.Database {
  const dbPath = resolve(process.cwd(), "corral.db");
  const db = new Database(dbPath);
  db.pragma("journal_mode = WAL");
  return db;
}

// â”€â”€â”€ YAML helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Locate corral.yaml by searching common paths relative to cwd.
 * Returns file contents or empty string if not found.
 */
function readCorralYaml(): string {
  const candidates = [
    "corral.yaml",
    "../corral.yaml",
    "../frontend/corral.yaml",
    "../../corral.yaml",
  ];
  for (const p of candidates) {
    const abs = resolve(process.cwd(), p);
    if (existsSync(abs)) return readFileSync(abs, "utf-8");
  }
  return "";
}

/**
 * Parse the corral.yaml plans section into an array of plan objects.
 * Uses a simple line-based parser â€” no yaml library required.
 */
function parsePlansFromYaml(content: string): Array<Record<string, any>> {
  const plans: Array<Record<string, any>> = [];
  const lines = content.split("\n");

  let inPlans  = false;
  let current: Record<string, any> | null = null;
  let inFeatures = false;

  for (const line of lines) {
    if (/^plans:/.test(line)) { inPlans = true; continue; }
    if (inPlans && /^\w/.test(line) && !/^\s|-/.test(line[0])) { inPlans = false; }
    if (!inPlans) continue;

    if (/^\s+-\s+name:/.test(line)) {
      if (current) plans.push(current);
      current = { name: line.split(":")[1]?.trim().replace(/['"]/g, ""), features: [] };
      inFeatures = false;
      continue;
    }
    if (!current) continue;

    if (/^\s+features:/.test(line)) { inFeatures = true; continue; }
    if (inFeatures && /^\s+-\s+/.test(line)) {
      current.features.push(line.replace(/^\s+-\s+/, "").trim());
      continue;
    }
    if (/^\s+\w/.test(line) && line.includes(":")) { inFeatures = false; }

    const match = line.match(/^\s+(\w+):\s*(.*)/);
    if (match) {
      const [, key, val] = match;
      const trimmed = val.trim().replace(/['"]/g, "");
      if (key === "price" || key === "trial_days") {
        current[key] = parseFloat(trimmed) || 0;
      } else {
        current[key] = trimmed;
      }
    }
  }
  if (current) plans.push(current);
  return plans;
}

// â”€â”€â”€ Auth helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function requireSession(req: express.Request) {
  const session = await auth.api.getSession({ headers: req.headers as any });
  if (!session?.user) throw Object.assign(new Error("Authentication required"), { status: 401 });
  return session;
}

async function requireAdmin(req: express.Request) {
  const session = await requireSession(req);
  if ((session.user as any).role !== "admin") {
    throw Object.assign(new Error("Admin access required"), { status: 403 });
  }
  return session;
}

// â”€â”€â”€ Stripe helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Load Stripe using createRequire for monorepo / ESM compat.
 * Avoids import() issues when stripe is installed in a sub-package.
 */
function getStripe(secretKey: string) {
  const _require = createRequire(join(process.cwd(), "package.json"));
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const Stripe = _require("stripe");
  return new Stripe(secretKey, { apiVersion: "2024-11-20.acacia" as any });
}

// â”€â”€â”€ Route mounting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Mount all Corral admin, profile, and billing routes onto an Express app.
 *
 * âš ï¸  Call this BEFORE app.use(express.json()) so the Stripe webhook handler
 *    receives the raw (unparsed) request body it needs for signature verification.
 */
export function mountCorralRoutes(app: express.Application): void {

  // â”€â”€ WEBHOOK (raw body â€” must be BEFORE express.json()) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * POST /api/billing/webhook
   * Stripe sends events here. Verifies signature when STRIPE_WEBHOOK_SECRET is set.
   * On checkout.session.completed: promotes user to paid plan.
   */
  app.post(
    "/api/billing/webhook",
    express.raw({ type: "application/json" }),
    async (req: express.Request, res: express.Response) => {
      try {
        const stripeKey = process.env.STRIPE_SECRET_KEY;
        if (!stripeKey) {
          res.status(500).json({ error: "STRIPE_SECRET_KEY not configured" });
          return;
        }

        const stripe    = getStripe(stripeKey);
        const sigHeader = req.headers["stripe-signature"] as string | undefined;
        const secret    = process.env.STRIPE_WEBHOOK_SECRET;

        let event: any;
        if (sigHeader && secret) {
          // Verify webhook signature (production)
          event = stripe.webhooks.constructEvent(req.body, sigHeader, secret);
        } else {
          // Dev/testing: parse raw JSON directly (no signature verification)
          event = JSON.parse(req.body.toString());
        }

        if (event.type === "checkout.session.completed") {
          const session = event.data.object;
          const userId  = session.metadata?.userId;
          const plan    = session.metadata?.plan || "{{PAID_PLAN}}";

          if (userId) {
            const db = getDb();
            db.prepare(
              'UPDATE "user" SET plan = ?, updatedAt = datetime("now") WHERE id = ?'
            ).run(plan, userId);
            db.close();
            console.log(`ğŸ¤  Corral: webhook â†’ upgraded user ${userId} â†’ plan "${plan}"`);
          }
        }

        res.json({ received: true });
      } catch (err: any) {
        console.error("Corral webhook error:", err.message);
        res.status(400).json({ error: err.message });
      }
    }
  );

  // â”€â”€ JSON router (all other routes need parsed body) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  const router = express.Router();
  router.use(express.json());

  // â”€â”€ Admin: list users â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * GET /api/admin/users
   * Returns all users ordered by join date. Admin only.
   */
  router.get("/api/admin/users", async (req, res) => {
    try {
      await requireAdmin(req);
      const db    = getDb();
      const users = db
        .prepare(
          'SELECT id, name, email, role, plan, createdAt FROM "user" ORDER BY createdAt DESC'
        )
        .all();
      db.close();
      res.json({ users });
    } catch (e: any) {
      res.status(e.status ?? 500).json({ error: e.message });
    }
  });

  // â”€â”€ Admin: update user plan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * PUT /api/admin/users/:id/plan
   * Body: { plan: string }
   * Admin only.
   */
  router.put("/api/admin/users/:id/plan", async (req, res) => {
    try {
      await requireAdmin(req);
      const { plan } = req.body;
      if (!plan || typeof plan !== "string") {
        res.status(400).json({ error: "plan is required" });
        return;
      }
      const db = getDb();
      db.prepare(
        'UPDATE "user" SET plan = ?, updatedAt = datetime("now") WHERE id = ?'
      ).run(plan, req.params.id);
      db.close();
      res.json({ ok: true });
    } catch (e: any) {
      res.status(e.status ?? 500).json({ error: e.message });
    }
  });

  // â”€â”€ Admin: update user role â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * PUT /api/admin/users/:id/role
   * Body: { role: "admin" | "user" }
   * Admin only.
   */
  router.put("/api/admin/users/:id/role", async (req, res) => {
    try {
      await requireAdmin(req);
      const { role } = req.body;
      if (!["admin", "user"].includes(role)) {
        res.status(400).json({ error: 'role must be "admin" or "user"' });
        return;
      }
      const db = getDb();
      db.prepare(
        'UPDATE "user" SET role = ?, updatedAt = datetime("now") WHERE id = ?'
      ).run(role, req.params.id);
      db.close();
      res.json({ ok: true });
    } catch (e: any) {
      res.status(e.status ?? 500).json({ error: e.message });
    }
  });

  // â”€â”€ Admin: list plans â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * GET /api/admin/plans
   * Reads plan definitions from corral.yaml. Admin only.
   */
  router.get("/api/admin/plans", async (req, res) => {
    try {
      await requireAdmin(req);
      const content = readCorralYaml();
      const plans   = parsePlansFromYaml(content);
      res.json({ plans });
    } catch (e: any) {
      res.status(e.status ?? 500).json({ error: e.message });
    }
  });

  // â”€â”€ Admin: add plan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * POST /api/admin/plans
   * Body: { name, display_name, price, trial_days, features[], cta }
   * Calls the create-corral CLI to append the plan to corral.yaml.
   * Admin only.
   */
  router.post("/api/admin/plans", async (req, res) => {
    try {
      await requireAdmin(req);

      const { name, display_name, price, trial_days, features, cta } = req.body;
      if (!name) { res.status(400).json({ error: "name is required" }); return; }

      const { execSync } = await import("child_process");
      let cmd = `npx create-corral add plan ${name} --price ${price ?? 0}`;
      if (trial_days && Number(trial_days) > 0) cmd += ` --trial ${trial_days}`;
      if (features?.length) cmd += ` --features "${(features as string[]).join(",")}"`;

      execSync(cmd, { stdio: "pipe" });
      res.json({ ok: true, name });
    } catch (e: any) {
      console.error("add plan error:", e.message);
      res.status(e.status ?? 500).json({ error: e.message });
    }
  });

  // â”€â”€ Profile: update name â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * PUT /api/profile/name
   * Body: { name: string }
   * Updates the display name of the authenticated user.
   */
  router.put("/api/profile/name", async (req, res) => {
    try {
      const session = await requireSession(req);
      const { name } = req.body;
      if (!name || typeof name !== "string" || !name.trim()) {
        res.status(400).json({ error: "name is required" });
        return;
      }
      const db = getDb();
      db.prepare(
        'UPDATE "user" SET name = ?, updatedAt = datetime("now") WHERE id = ?'
      ).run(name.trim(), session.user.id);
      db.close();
      res.json({ ok: true });
    } catch (e: any) {
      res.status(e.status ?? 500).json({ error: e.message });
    }
  });

  // â”€â”€ Profile: change password â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * PUT /api/profile/password
   * Body: { currentPassword: string, newPassword: string }
   * Delegates to Better Auth's changePassword API.
   */
  router.put("/api/profile/password", async (req, res) => {
    try {
      await requireSession(req); // ensure authenticated before delegating
      const { currentPassword, newPassword } = req.body;
      if (!currentPassword || !newPassword) {
        res.status(400).json({ error: "currentPassword and newPassword are required" });
        return;
      }
      if (newPassword.length < 8) {
        res.status(400).json({ error: "New password must be at least 8 characters" });
        return;
      }
      await auth.api.changePassword({
        body: { currentPassword, newPassword },
        headers: req.headers as any,
      });
      res.json({ ok: true });
    } catch (e: any) {
      res.status(e.status ?? 400).json({ error: e.message || "Failed to change password" });
    }
  });

  // â”€â”€ Profile: delete account â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * DELETE /api/profile/delete
   * Body: { confirmEmail: string }
   * Deletes all sessions, accounts, and the user row. Requires email confirmation.
   */
  router.delete("/api/profile/delete", async (req, res) => {
    try {
      const session = await requireSession(req);
      const { confirmEmail } = req.body;

      if (!confirmEmail) {
        res.status(400).json({ error: "confirmEmail is required" });
        return;
      }
      if (confirmEmail !== session.user.email) {
        res.status(400).json({ error: "Email confirmation doesn't match" });
        return;
      }

      const db = getDb();
      db.prepare('DELETE FROM "session" WHERE userId = ?').run(session.user.id);
      db.prepare('DELETE FROM "account" WHERE userId = ?').run(session.user.id);
      db.prepare('DELETE FROM "user"    WHERE id      = ?').run(session.user.id);
      db.close();

      res.json({ ok: true });
    } catch (e: any) {
      res.status(e.status ?? 500).json({ error: e.message });
    }
  });

  // â”€â”€ Billing: create Stripe Checkout session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * POST /api/billing/checkout
   * Body: { plan?: string }  â€” defaults to "{{PAID_PLAN}}"
   *
   * Reads the Stripe price ID from corral.yaml (stripe_price_id field).
   * Returns { url } â€” open this in a new tab on the frontend.
   *
   * On success, Stripe redirects to SUCCESS_URL and fires the webhook.
   * Requires STRIPE_SECRET_KEY in environment.
   */
  router.post("/api/billing/checkout", async (req, res) => {
    try {
      const session = await requireSession(req);

      const stripeKey = process.env.STRIPE_SECRET_KEY;
      if (!stripeKey) {
        res.status(500).json({ error: "STRIPE_SECRET_KEY is not set" });
        return;
      }

      const stripe     = getStripe(stripeKey);
      const targetPlan = (req.body.plan as string | undefined) || "{{PAID_PLAN}}";

      // Locate Stripe price ID in corral.yaml
      const yamlContent = readCorralYaml();
      // Match: name: <plan> ... stripe_price_id: price_xxx
      const priceRegex = new RegExp(
        `name:\\s*${targetPlan}[\\s\\S]*?stripe_price_id:\\s*["']?([\\w_]+)`,
        "i"
      );
      const priceMatch = yamlContent.match(priceRegex);
      const priceId    = priceMatch?.[1]?.replace(/['"]/g, "");

      if (!priceId) {
        res.status(500).json({
          error: `No Stripe price found for plan "${targetPlan}". Run: npx create-corral stripe push`,
        });
        return;
      }

      const trialDays: number = {{TRIAL_DAYS}};

      const checkoutSession = await stripe.checkout.sessions.create({
        mode: "subscription",
        customer_email: session.user.email,
        line_items: [{ price: priceId, quantity: 1 }],
        ...(trialDays > 0 && {
          subscription_data: { trial_period_days: trialDays },
        }),
        success_url: "{{SUCCESS_URL}}",
        cancel_url:  "{{CANCEL_URL}}",
        metadata: {
          userId: session.user.id,
          plan:   targetPlan,
        },
      });

      res.json({ url: checkoutSession.url });
    } catch (e: any) {
      console.error("Corral checkout error:", e.message);
      res.status(500).json({ error: e.message });
    }
  });

  // â”€â”€ Mount router â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  app.use(router);
}
