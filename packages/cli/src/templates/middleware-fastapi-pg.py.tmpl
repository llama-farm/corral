# {{APP_NAME}} â€” Corral Auth Middleware (FastAPI + PostgreSQL)
# Generated by `corral init`
# Same as SQLite version but uses asyncpg for async PostgreSQL.

import os
from typing import Optional
from fastapi import Request, HTTPException, Depends

# pip install asyncpg
import asyncpg

DATABASE_URL = os.environ.get("DATABASE_URL", "{{DB_URL}}")
COOKIE_NAME = "better-auth.session_token"
PLAN_RANK = {"free": 0, "pro": 1, "team": 2, "enterprise": 3}

_pool: Optional[asyncpg.Pool] = None


async def get_pool() -> asyncpg.Pool:
    global _pool
    if _pool is None:
        _pool = await asyncpg.create_pool(DATABASE_URL, min_size=2, max_size=10)
    return _pool


def _get_token(request: Request) -> Optional[str]:
    token = request.cookies.get(COOKIE_NAME)
    if token:
        return token
    auth_header = request.headers.get("authorization", "")
    if auth_header.startswith("Bearer "):
        return auth_header[7:]
    return None


async def _validate_token(token: str) -> Optional[dict]:
    pool = await get_pool()
    row = await pool.fetchrow("""
        SELECT u.id, u.email, u.name, u.plan, u.role,
               u."emailVerified", u.image, u."createdAt"
        FROM "session" s
        JOIN "user" u ON s."userId" = u.id
        WHERE s.token = $1
          AND s."expiresAt" > NOW()
    """, token)

    if not row:
        return None
    return {
        "id": row["id"],
        "email": row["email"],
        "name": row["name"],
        "plan": row["plan"] or "free",
        "role": row["role"] or "user",
        "emailVerified": row["emailVerified"],
        "image": row["image"],
        "createdAt": str(row["createdAt"]),
    }


async def get_current_user(request: Request) -> dict:
    token = _get_token(request)
    if not token:
        raise HTTPException(status_code=401, detail="Authentication required")
    user = await _validate_token(token)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid or expired session")
    return user


async def get_optional_user(request: Request) -> Optional[dict]:
    token = _get_token(request)
    if not token:
        return None
    return await _validate_token(token)


def require_plan(plan: str):
    required_rank = PLAN_RANK.get(plan, 1)

    async def _check(user: dict = Depends(get_current_user)) -> dict:
        user_rank = PLAN_RANK.get(user.get("plan", "free"), 0)
        if user_rank < required_rank:
            raise HTTPException(status_code=403, detail=f"{plan} plan required")
        return user

    return _check
