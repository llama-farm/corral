# {{APP_NAME}} — Corral Auth Middleware (FastAPI)
# Generated by `corral init`
#
# Validates sessions from the shared Corral database.
# All auth operations (login, signup, payments) are handled by the
# Corral auth server (Node.js). This middleware just READS session state.
#
# Usage:
#   from middleware.corral import get_current_user, require_plan
#
#   @app.get("/api/protected")
#   async def protected(user = Depends(get_current_user)):
#       return {"hello": user["name"], "plan": user["plan"]}
#
#   @app.get("/api/pro-feature")
#   async def pro_feature(user = Depends(require_plan("pro"))):
#       return {"data": "premium stuff"}

import sqlite3
import os
from functools import lru_cache
from typing import Optional
from fastapi import Request, HTTPException, Depends

# ─── Configuration ──────────────────────────────────────────────────
DB_PATH = os.environ.get("CORRAL_DB", "{{DB_PATH}}")
COOKIE_NAME = "better-auth.session_token"
PLAN_RANK = {"free": 0, "pro": 1, "team": 2, "enterprise": 3}


# ─── Database ───────────────────────────────────────────────────────
def _get_db() -> sqlite3.Connection:
    """Get a database connection. SQLite is thread-safe in WAL mode."""
    db = sqlite3.connect(DB_PATH)
    db.row_factory = sqlite3.Row
    return db


# ─── Session Validation ────────────────────────────────────────────
def _validate_token(token: str) -> Optional[dict]:
    """Look up a session token and return the user, or None."""
    db = _get_db()
    try:
        row = db.execute("""
            SELECT u.id, u.email, u.name, u.plan, u.role,
                   u.emailVerified, u.image, u.createdAt,
                   s.expiresAt, s.id as sessionId
            FROM "session" s
            JOIN "user" u ON s.userId = u.id
            WHERE s.token = ?
              AND s.expiresAt > datetime('now')
        """, (token,)).fetchone()

        if not row:
            return None

        return {
            "id": row["id"],
            "email": row["email"],
            "name": row["name"],
            "plan": row["plan"] or "free",
            "role": row["role"] or "user",
            "emailVerified": bool(row["emailVerified"]),
            "image": row["image"],
            "createdAt": row["createdAt"],
            "sessionId": row["sessionId"],
        }
    finally:
        db.close()


def _get_token(request: Request) -> Optional[str]:
    """Extract auth token from cookie or Authorization header."""
    # Cookie (browser sessions)
    token = request.cookies.get(COOKIE_NAME)
    if token:
        return token

    # Bearer token (CLI / API keys / device tokens)
    auth_header = request.headers.get("authorization", "")
    if auth_header.startswith("Bearer "):
        return auth_header[7:]

    return None


# ─── FastAPI Dependencies ──────────────────────────────────────────
async def get_current_user(request: Request) -> dict:
    """
    FastAPI dependency — returns the authenticated user or raises 401.

    Usage:
        @app.get("/api/me")
        async def me(user = Depends(get_current_user)):
            return user
    """
    token = _get_token(request)
    if not token:
        raise HTTPException(status_code=401, detail="Authentication required")

    user = _validate_token(token)
    if not user:
        raise HTTPException(status_code=401, detail="Invalid or expired session")

    return user


async def get_optional_user(request: Request) -> Optional[dict]:
    """
    FastAPI dependency — returns user or None (doesn't raise).
    Use for pages that work for both anonymous and authenticated users.

    Usage:
        @app.get("/api/dashboard")
        async def dashboard(user = Depends(get_optional_user)):
            if user:
                return {"personalized": True, "plan": user["plan"]}
            return {"personalized": False}
    """
    token = _get_token(request)
    if not token:
        return None
    return _validate_token(token)


def require_plan(plan: str):
    """
    FastAPI dependency factory — requires a specific plan level.

    Usage:
        @app.get("/api/analytics")
        async def analytics(user = Depends(require_plan("pro"))):
            return {"data": "premium analytics"}
    """
    required_rank = PLAN_RANK.get(plan, 1)

    async def _check(user: dict = Depends(get_current_user)) -> dict:
        user_rank = PLAN_RANK.get(user.get("plan", "free"), 0)
        if user_rank < required_rank:
            raise HTTPException(
                status_code=403,
                detail={
                    "error": f"{plan} plan required",
                    "currentPlan": user.get("plan", "free"),
                    "requiredPlan": plan,
                },
            )
        return user

    return _check


# ─── Utility ───────────────────────────────────────────────────────
def get_user_by_id(user_id: str) -> Optional[dict]:
    """Look up a user by ID (for background jobs, webhooks, etc.)."""
    db = _get_db()
    try:
        row = db.execute(
            'SELECT id, email, name, plan, role FROM "user" WHERE id = ?',
            (user_id,),
        ).fetchone()
        if not row:
            return None
        return dict(row)
    finally:
        db.close()


def get_user_by_email(email: str) -> Optional[dict]:
    """Look up a user by email."""
    db = _get_db()
    try:
        row = db.execute(
            'SELECT id, email, name, plan, role FROM "user" WHERE email = ?',
            (email,),
        ).fetchone()
        if not row:
            return None
        return dict(row)
    finally:
        db.close()
